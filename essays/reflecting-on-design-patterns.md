---
layout: essay
type: essay
title: "Building With Blueprints"
# All dates must be YYYY-MM-DD format!
date: 2025-07-24
published: true
labels:
  - Software Engineering
  - Design Patterns
---

## The Pattern Beneath the Surface

It’s like we’re not reinventing the wheel every time we want to build a project. We follow a pattern—whether we realize it or not. In fact, I’d argue that most of us start following patterns long before we even know what design patterns are. It happens naturally. We watch others code, we observe how projects are structured, we read tutorials—and without realizing it, we begin mimicking what works. Then over time, those patterns stop being something we copy, and start becoming part of our instinct.

To me, design patterns feel a lot like **muscle memory**. They aren’t about limiting creativity—they’re about removing obstacles. They reduce the friction of decision-making by giving us a solid, proven structure to build from. They let us focus less on the “how” and more on the “why”. With a pattern in place, it’s easier to stay focused on the creative, meaningful parts of development.

And honestly, that’s a relief. Programming is hard enough already. Patterns bring clarity to chaos.

## Patterns I’ve Picked Up Along the Way

When I think back to the code I’ve written—especially in the last few months—I realize that I’ve been using design patterns all over the place. Sometimes consciously. Sometimes not.

One of the biggest ones lately has been **component-based design**, especially with Next.js. Breaking a project into individual, reusable parts isn’t just good practice—it’s a lifesaver when it comes to managing complexity. It keeps code organized, scalable, and easy to work with. Combine that with the **DRY principle** (“Don’t Repeat Yourself”), and suddenly I’m building systems that are cleaner, more maintainable, and more efficient.

I’ve also used the **Factory pattern**, like when a `createUser()` function returns a different object depending on the role. Or the **Iterator pattern**, which shows up constantly—whether it's a `for` loop, `.map()`, or anything else that helps process a collection of data.

We even touched on the **Singleton pattern** briefly during our Spring Boot activities. Shared state? Shared service? One instance only? That pattern was in there, doing its thing.

And then there’s **Model-View-Controller (MVC)**, which is almost second nature now. Separate your data, your logic, and your visuals. It sounds simple, but when you really internalize it, your entire approach to building applications starts to change.

Some patterns even lead to others. Like how adopting component-based design led me to create **shared components**, which are themselves a pattern in how we eliminate repetition and improve maintainability. That kind of pattern-on-pattern mindset feels like a sign of leveling up.

## The Developer I Am (And Am Still Becoming)

If someone asked me what kind of developer I am, I don’t think I could give a straight answer. I’m still becoming. But what I do know is this: **every developer is a problem solver**. You can’t write code without solving problems. Sometimes you’re fixing bugs. Sometimes you’re creating new things out of nothing. Sometimes you’re just trying to get something to work, even if it’s not pretty.

But you’re always solving.

I also believe that **programming demands creativity**. You have to imagine what your solution will look like. You have to chart a path from Point A to Point B, and then figure out how to fill in the gaps. And the cool thing is—it’s never just one path. There are always options. Patterns help guide us, but vision helps us choose.

Every time I hit a wall and start digging deeper—asking “why does this work?” instead of just “how does it work?”—I find a new piece of the puzzle. And the more pieces I find, the more the big picture starts to make sense.

## Patterns in Life and in Code

Design patterns don’t only live in codebases. They show up everywhere in my life.

Take the gym. I don’t just walk in and start lifting the heaviest weight I can. I warm up, stretch, start light, build up. There’s a **routine**. A flow. A structure. Same goes for my daily life. I start with productivity—work, school, gym—and only after I’ve taken care of what needs doing do I unwind. That structure gives me freedom. It gives me consistency.

That’s what patterns do. They give us a rhythm to follow so that we’re not constantly starting from scratch. They let us move faster, think clearer, and focus on what really matters.

## Knowing When to Break the Pattern

But here’s the thing—patterns aren’t rules. They’re guidelines. They’re tools. And sometimes, they’re not the right tool for the job.

As developers, we need to develop **judgment**. Sometimes a pattern is the perfect fit. Other times, it boxes you in. Knowing when to follow a pattern—and when to break away from it—is a skill that only comes with time, experience, and maybe a few hard lessons.

That’s part of what makes software engineering such a craft. It’s not about memorizing solutions. It’s about knowing when to trust a pattern, when to improvise, and when to invent something entirely new.

